{
    "docs": [
        {
            "location": "/", 
            "text": "CSC 320\n\n\nConnex\n\n\n\n\nInstructor\n: Bruce Kapron\n\n\nOffice\n: ECS 620\n\n\nEmail\n: \nbmkapron@cs.uvic.ca\n\n\nOffice Hours\n: TBA\n\n\n\n\nOverview\n\n\nThe goal of this course is to study the fundamental power and limitations of computation. We will use abstract models to gain an understanding of what can and cannot be achieved using computational devices. We will study the Turing machine, a model that captures everything that can be computed in principle, and formally show the existence of problems that cannot be solved by this model. We also examine restricted versions of Turing machines, such as finite automata, context-free grammars, and time- and space- bounded machines, which are often useful in practice and have structure which will allow use to give deep characterizations enabling us to understand their power. We will define what it means to show that one problem is harder to solve than another, and use this idea both to prove that some problems are hard to solve and also to develop generic techniques for solving large classes of problems. In particular, we will look at the Satisfiability problem, which will provide us with a general method for solving many kinds of optimization problems, and which is also a key component of the problem at the heart of modern computer science -- P vs NP.\n\n\nTextbook\n\n\nTBA\n\n\nAssessment\n\n\n\n\n\n\n\n\nTask\n\n\nWeight\n\n\n\n\n\n\n\n\n\n\nAssignments\n\n\n5%\n\n\n\n\n\n\nProject\n\n\n10%\n\n\n\n\n\n\nMidterm\n\n\n35%\n\n\n\n\n\n\nFinal\n\n\n50%", 
            "title": "Home"
        }, 
        {
            "location": "/#csc-320", 
            "text": "", 
            "title": "CSC 320"
        }, 
        {
            "location": "/#connex", 
            "text": "Instructor : Bruce Kapron  Office : ECS 620  Email :  bmkapron@cs.uvic.ca  Office Hours : TBA", 
            "title": "Connex"
        }, 
        {
            "location": "/#overview", 
            "text": "The goal of this course is to study the fundamental power and limitations of computation. We will use abstract models to gain an understanding of what can and cannot be achieved using computational devices. We will study the Turing machine, a model that captures everything that can be computed in principle, and formally show the existence of problems that cannot be solved by this model. We also examine restricted versions of Turing machines, such as finite automata, context-free grammars, and time- and space- bounded machines, which are often useful in practice and have structure which will allow use to give deep characterizations enabling us to understand their power. We will define what it means to show that one problem is harder to solve than another, and use this idea both to prove that some problems are hard to solve and also to develop generic techniques for solving large classes of problems. In particular, we will look at the Satisfiability problem, which will provide us with a general method for solving many kinds of optimization problems, and which is also a key component of the problem at the heart of modern computer science -- P vs NP.", 
            "title": "Overview"
        }, 
        {
            "location": "/#textbook", 
            "text": "TBA", 
            "title": "Textbook"
        }, 
        {
            "location": "/#assessment", 
            "text": "Task  Weight      Assignments  5%    Project  10%    Midterm  35%    Final  50%", 
            "title": "Assessment"
        }, 
        {
            "location": "/0-Introduction/", 
            "text": "Introduction\n\n\nLecture 1 - January 5, 2017\n\n\nWhat \nproblems\n are \nsolvable\n by a \ncomputer\n?\n\n\nTo answer this question we need to define these terms.\n\n\nWe will examine three computational models,\n\n\n\n\nComplexity Theory\n\n\nComputability Theory\n\n\nAutomata Theory", 
            "title": "0 Introduction"
        }, 
        {
            "location": "/0-Introduction/#introduction", 
            "text": "Lecture 1 - January 5, 2017  What  problems  are  solvable  by a  computer ?  To answer this question we need to define these terms.  We will examine three computational models,   Complexity Theory  Computability Theory  Automata Theory", 
            "title": "Introduction"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/", 
            "text": "Alphabets and Languages\n\n\nLecture 1 - January 5, 2017\n\n\nStrings and Symbols\n\n\ndefinitions\n:\n\n\n\n\nAn \nalphabet\n is a finite set of set of symbols, we denote an arbitrary alphabet $\\Sigma$.\n\n\nA \nstring\n is a finite sequence of symbols from the alphabet.\n\n\nThe \nempty string\n is the string with no symbols denoted $\\epsilon$.\n\n\n\n\nOperations and Relations on Strings\n\n\nConcatenation\n\n\nGiven two strings $x$ and $y$ the \nconcatenation\n of $x$ and $y$ denoted $xy$ is the the two string combined end-to-end.\n\n\nConcatenation is associative, so $xyz = (xy)z = x(yz)$.\n\n\nWe let $x^n$ be $x$ concatenated with itself $n$ times.\n\n\nSubstrings\n\n\nA string $v$ is a \nsubstring\n of $w$ if and only if there exist strings $x$ and $y$ such that\n\n\n\n\n\n    W = xvy,\n\n\n\n\n\nIf $x = \\epsilon$ then $v$ is a \nprefix\n of $w$, if $y = \\epsilon$ then $v$ is a \nsuffix\n of $w$.\n\n\nReversal\n\n\nGive a string $w$, the \nreversal\n of $w$ is denoted $w^R$.\n\n\nLanguages\n\n\ndefinition\n: A \nlanguage\n is a set of strings over an alphabet. We can apply set opertations like,\n\n\n\n\nUnion\n\n\nIntersection\n\n\nSet Difference.\n\n\n\n\nGiven a language $A$, the \ncomplement\n of $A$, denoted $\\bar A$, is\n\n\n\n\n\n    \\bar A = \\Sigma - A.", 
            "title": "1 Alphabets and Languages"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#alphabets-and-languages", 
            "text": "Lecture 1 - January 5, 2017", 
            "title": "Alphabets and Languages"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#strings-and-symbols", 
            "text": "definitions :   An  alphabet  is a finite set of set of symbols, we denote an arbitrary alphabet $\\Sigma$.  A  string  is a finite sequence of symbols from the alphabet.  The  empty string  is the string with no symbols denoted $\\epsilon$.", 
            "title": "Strings and Symbols"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#operations-and-relations-on-strings", 
            "text": "", 
            "title": "Operations and Relations on Strings"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#concatenation", 
            "text": "Given two strings $x$ and $y$ the  concatenation  of $x$ and $y$ denoted $xy$ is the the two string combined end-to-end.  Concatenation is associative, so $xyz = (xy)z = x(yz)$.  We let $x^n$ be $x$ concatenated with itself $n$ times.", 
            "title": "Concatenation"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#substrings", 
            "text": "A string $v$ is a  substring  of $w$ if and only if there exist strings $x$ and $y$ such that   \n    W = xvy,   If $x = \\epsilon$ then $v$ is a  prefix  of $w$, if $y = \\epsilon$ then $v$ is a  suffix  of $w$.", 
            "title": "Substrings"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#reversal", 
            "text": "Give a string $w$, the  reversal  of $w$ is denoted $w^R$.", 
            "title": "Reversal"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#languages", 
            "text": "definition : A  language  is a set of strings over an alphabet. We can apply set opertations like,   Union  Intersection  Set Difference.   Given a language $A$, the  complement  of $A$, denoted $\\bar A$, is   \n    \\bar A = \\Sigma - A.", 
            "title": "Languages"
        }
    ]
}