{
    "docs": [
        {
            "location": "/", 
            "text": "CSC 320\n\n\nConnex\n\n\n\n\nInstructor\n: Bruce Kapron\n\n\nOffice\n: ECS 620\n\n\nEmail\n: \nbmkapron@cs.uvic.ca\n\n\nOffice Hours\n: TBA\n\n\n\n\nOverview\n\n\nThe goal of this course is to study the fundamental power and limitations of computation. We will use abstract models to gain an understanding of what can and cannot be achieved using computational devices. We will study the Turing machine, a model that captures everything that can be computed in principle, and formally show the existence of problems that cannot be solved by this model. We also examine restricted versions of Turing machines, such as finite automata, context-free grammars, and time- and space- bounded machines, which are often useful in practice and have structure which will allow use to give deep characterizations enabling us to understand their power. We will define what it means to show that one problem is harder to solve than another, and use this idea both to prove that some problems are hard to solve and also to develop generic techniques for solving large classes of problems. In particular, we will look at the Satisfiability problem, which will provide us with a general method for solving many kinds of optimization problems, and which is also a key component of the problem at the heart of modern computer science \n P vs NP.\n\n\nTextbook\n\n\nTBA\n\n\nAssessment\n\n\n\n\n\n\n\n\nTask\n\n\nWeight\n\n\n\n\n\n\n\n\n\n\nAssignments\n\n\n5%\n\n\n\n\n\n\nProject\n\n\n10%\n\n\n\n\n\n\nMidterm\n\n\n35%\n\n\n\n\n\n\nFinal\n\n\n50%", 
            "title": "Home"
        }, 
        {
            "location": "/#csc-320", 
            "text": "", 
            "title": "CSC 320"
        }, 
        {
            "location": "/#connex", 
            "text": "Instructor : Bruce Kapron  Office : ECS 620  Email :  bmkapron@cs.uvic.ca  Office Hours : TBA", 
            "title": "Connex"
        }, 
        {
            "location": "/#overview", 
            "text": "The goal of this course is to study the fundamental power and limitations of computation. We will use abstract models to gain an understanding of what can and cannot be achieved using computational devices. We will study the Turing machine, a model that captures everything that can be computed in principle, and formally show the existence of problems that cannot be solved by this model. We also examine restricted versions of Turing machines, such as finite automata, context-free grammars, and time- and space- bounded machines, which are often useful in practice and have structure which will allow use to give deep characterizations enabling us to understand their power. We will define what it means to show that one problem is harder to solve than another, and use this idea both to prove that some problems are hard to solve and also to develop generic techniques for solving large classes of problems. In particular, we will look at the Satisfiability problem, which will provide us with a general method for solving many kinds of optimization problems, and which is also a key component of the problem at the heart of modern computer science   P vs NP.", 
            "title": "Overview"
        }, 
        {
            "location": "/#textbook", 
            "text": "TBA", 
            "title": "Textbook"
        }, 
        {
            "location": "/#assessment", 
            "text": "Task  Weight      Assignments  5%    Project  10%    Midterm  35%    Final  50%", 
            "title": "Assessment"
        }, 
        {
            "location": "/0-Introduction/", 
            "text": "Introduction\n\n\nLecture 1 - January 5, 2017\n\n\nWhat \nproblems\n are \nsolvable\n by a \ncomputer\n?\n\n\nTo answer this question we need to define these terms.\n\n\nWe will examine three computational models,\n\n\n\n\nComplexity Theory\n\n\nComputability Theory\n\n\nAutomata Theory", 
            "title": "Introduction"
        }, 
        {
            "location": "/0-Introduction/#introduction", 
            "text": "Lecture 1 - January 5, 2017  What  problems  are  solvable  by a  computer ?  To answer this question we need to define these terms.  We will examine three computational models,   Complexity Theory  Computability Theory  Automata Theory", 
            "title": "Introduction"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/", 
            "text": "Alphabets and Languages\n\n\nStrings and Symbols\n\n\ndefinitions\n:\n\n\n\n\nAn \nalphabet\n is a finite set of set of symbols, we denote an arbitrary alphabet $\\Sigma$.\n\n\nA \nstring\n is a finite sequence of symbols from the alphabet.\n\n\nThe \nempty string\n is the string with no symbols denoted $\\epsilon$.\n\n\n\n\nOperations and Relations on Strings\n\n\nConcatenation\n\n\nGiven two strings $x$ and $y$ the \nconcatenation\n of $x$ and $y$ denoted $xy$ is the the two string combined end-to-end.\n\n\nConcatenation is associative, so $xyz = (xy)z = x(yz)$.\n\n\nWe let $x^n$ be $x$ concatenated with itself $n$ times.\n\n\nSubstrings\n\n\nA string $v$ is a \nsubstring\n of $w$ if and only if there exist strings $x$ and $y$ such that\n\n\n\n\n\n    W = xvy,\n\n\n\n\n\nIf $x = \\epsilon$ then $v$ is a \nprefix\n of $w$, if $y = \\epsilon$ then $v$ is a \nsuffix\n of $w$.\n\n\nReversal\n\n\nGive a string $w$, the \nreversal\n of $w$ is denoted $w^R$.\n\n\nLanguages\n\n\ndefinition\n: A \nlanguage\n is a set of strings over an alphabet. We can apply set opertations like,\n\n\n\n\nUnion\n\n\nIntersection\n\n\nSet Difference.\n\n\n\n\nGiven a language $A$, the \ncomplement\n of $A$, denoted $\\bar A$, is\n\n\n\n\n\n    \\bar A = \\Sigma - A.\n\n\n\n\n\nGiven languages $L_1$ and $L_2$ over $\\Sigma$, their \nconcatenation\n is,\n\n\n\n\n\\begin{aligned}\n    L = L_1 \\cdot L_2 = \\{w \\in \\Sigma^* : w = xy; x \\in L_1, y \\in L_2 \\}.\n\\end{aligned}\n\n\n\n\nSometime we denote $L_1 \\cdot L_2$ as $L_1 L_2$.\n\n\nKleene star\n\n\ndefinition\n: The \nKleene star\n of a language $L$, denoted $L^*$ is the set of all strings obtained by concatenating more or more strings from $L$, i.e.,\n\n\n\n\n\\begin{aligned}\n    L^* = \\{w \\in \\Sigma^* : w = w_1 w_2 \\ldots w_k; k \\ge 0, w_i \\in L \\}.\n\\end{aligned}\n\n\n\n\nFor example, the star of $\\Sigma$ is $\\Sigma^*$, the star of $\\varnothing$ is ${\\epsilon}$.\n\n\nProblems\n\n\nDecision vs Search\n\n\n\n\nDecision\n: Given a formula $\\varphi(x_1,x_2,\\ldots)$ is there a setting of variables such that $\\varphi = T$.\n\n\nSearch\n: Given $\\varphi$, return a satisfying assignment if one exists.\n\n\n\n\nSome examples,\n\n\n\n\nIs a graph 3-colourable?\n is a \ndecision\n problem.\n\n\nWhat is a  3-colouring of this graph?\n is a \nsearch\n problem.", 
            "title": "Alphabets and Languages"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#alphabets-and-languages", 
            "text": "", 
            "title": "Alphabets and Languages"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#strings-and-symbols", 
            "text": "definitions :   An  alphabet  is a finite set of set of symbols, we denote an arbitrary alphabet $\\Sigma$.  A  string  is a finite sequence of symbols from the alphabet.  The  empty string  is the string with no symbols denoted $\\epsilon$.", 
            "title": "Strings and Symbols"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#operations-and-relations-on-strings", 
            "text": "", 
            "title": "Operations and Relations on Strings"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#concatenation", 
            "text": "Given two strings $x$ and $y$ the  concatenation  of $x$ and $y$ denoted $xy$ is the the two string combined end-to-end.  Concatenation is associative, so $xyz = (xy)z = x(yz)$.  We let $x^n$ be $x$ concatenated with itself $n$ times.", 
            "title": "Concatenation"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#substrings", 
            "text": "A string $v$ is a  substring  of $w$ if and only if there exist strings $x$ and $y$ such that   \n    W = xvy,   If $x = \\epsilon$ then $v$ is a  prefix  of $w$, if $y = \\epsilon$ then $v$ is a  suffix  of $w$.", 
            "title": "Substrings"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#reversal", 
            "text": "Give a string $w$, the  reversal  of $w$ is denoted $w^R$.", 
            "title": "Reversal"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#languages", 
            "text": "definition : A  language  is a set of strings over an alphabet. We can apply set opertations like,   Union  Intersection  Set Difference.   Given a language $A$, the  complement  of $A$, denoted $\\bar A$, is   \n    \\bar A = \\Sigma - A.   Given languages $L_1$ and $L_2$ over $\\Sigma$, their  concatenation  is,   \\begin{aligned}\n    L = L_1 \\cdot L_2 = \\{w \\in \\Sigma^* : w = xy; x \\in L_1, y \\in L_2 \\}.\n\\end{aligned}   Sometime we denote $L_1 \\cdot L_2$ as $L_1 L_2$.", 
            "title": "Languages"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#kleene-star", 
            "text": "definition : The  Kleene star  of a language $L$, denoted $L^*$ is the set of all strings obtained by concatenating more or more strings from $L$, i.e.,   \\begin{aligned}\n    L^* = \\{w \\in \\Sigma^* : w = w_1 w_2 \\ldots w_k; k \\ge 0, w_i \\in L \\}.\n\\end{aligned}   For example, the star of $\\Sigma$ is $\\Sigma^*$, the star of $\\varnothing$ is ${\\epsilon}$.", 
            "title": "Kleene star"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#problems", 
            "text": "", 
            "title": "Problems"
        }, 
        {
            "location": "/1-Alphabets-and-Languages/#decision-vs-search", 
            "text": "Decision : Given a formula $\\varphi(x_1,x_2,\\ldots)$ is there a setting of variables such that $\\varphi = T$.  Search : Given $\\varphi$, return a satisfying assignment if one exists.   Some examples,   Is a graph 3-colourable?  is a  decision  problem.  What is a  3-colouring of this graph?  is a  search  problem.", 
            "title": "Decision vs Search"
        }, 
        {
            "location": "/2-Finite-Automata/", 
            "text": "Finite Automata\n\n\nWe use \nfinite automata\n to model systems with a fixed number of states. We also call these \ndeterministic finite automata (DFAs)\n.\n\n\nExample\n\n\nA door controller is a finite automata. Suppose it has three components:\n\n\n\n\nFront Pad\n\n\nDoor\n\n\nRear Pad.\n\n\n\n\nThe door has two possible \nstates\n, \nOPEN\n or \nCLOSED\n. There are four possible \nsignals\n (or \ninputs\n):\n\n\n\n\nFRONT\n\n\nREAR\n\n\nBOTH\n\n\nNEITHER\n\n\n\n\nWe can represent this with a state diagram.\n\n\nA Finite Automaton\n\n\ndefinition\n: A \nfinite automaton (FA)\n is a structure, for a machine $M$, $M = (Q, \\Sigma, \\delta, q_0, F)$, where\n\n\n\n\n$Q = {q_1, q_2, \\ldots}$ is a finite \nset of states\n\n\n$\\Sigma$ is the \ninput symbols\n or alphabet\n\n\n$\\delta$ is the \ntransition function\n\n\n$q_0 \\in Q$ is the \nstarting state\n\n\n$F \\subseteq Q$ is the set of \naccept states\n or \nfinal states\n\n\n\n\nThe language of the machine $M$ is the set $L$ of all strings $M$ accepts.\n\n\nComputation or Acceptance\n\n\ndefinition\n: Given a finite automaton $M = (Q, \\Sigma, \\delta, q_0, F)$, a string $w$ over $\\Sigma$ where $w = w_1 w_2 \\ldots w_n$.\n\n\nThen $M$ \naccepts\n $w$ if there is a sequence of states $r_0,r_1,\\ldots,r_n$ in $Q$ such that\n\n\nExample\n\n\nConstruct a finite automaton accepting the following language:\n\n$$\n    { x \\in {a,b}^* | \\text{ $x$ contains a substring of 3 consecutive $a$\ns} }\n$$\n\n\n\n\nClosure\n\n\ndefinition\n: A set is \nclosed\n under an operation if the result of the operation on an element of the set is also an element of the set.\n\n\nTheorem\n\n\nIf $L_1$ and $L_2$ are regular languages then so is $L_1 \\cup L_2$.", 
            "title": "Finite Automata"
        }, 
        {
            "location": "/2-Finite-Automata/#finite-automata", 
            "text": "We use  finite automata  to model systems with a fixed number of states. We also call these  deterministic finite automata (DFAs) .", 
            "title": "Finite Automata"
        }, 
        {
            "location": "/2-Finite-Automata/#example", 
            "text": "A door controller is a finite automata. Suppose it has three components:   Front Pad  Door  Rear Pad.   The door has two possible  states ,  OPEN  or  CLOSED . There are four possible  signals  (or  inputs ):   FRONT  REAR  BOTH  NEITHER   We can represent this with a state diagram.", 
            "title": "Example"
        }, 
        {
            "location": "/2-Finite-Automata/#a-finite-automaton", 
            "text": "definition : A  finite automaton (FA)  is a structure, for a machine $M$, $M = (Q, \\Sigma, \\delta, q_0, F)$, where   $Q = {q_1, q_2, \\ldots}$ is a finite  set of states  $\\Sigma$ is the  input symbols  or alphabet  $\\delta$ is the  transition function  $q_0 \\in Q$ is the  starting state  $F \\subseteq Q$ is the set of  accept states  or  final states   The language of the machine $M$ is the set $L$ of all strings $M$ accepts.", 
            "title": "A Finite Automaton"
        }, 
        {
            "location": "/2-Finite-Automata/#computation-or-acceptance", 
            "text": "definition : Given a finite automaton $M = (Q, \\Sigma, \\delta, q_0, F)$, a string $w$ over $\\Sigma$ where $w = w_1 w_2 \\ldots w_n$.  Then $M$  accepts  $w$ if there is a sequence of states $r_0,r_1,\\ldots,r_n$ in $Q$ such that", 
            "title": "Computation or Acceptance"
        }, 
        {
            "location": "/2-Finite-Automata/#example_1", 
            "text": "Construct a finite automaton accepting the following language: \n$$\n    { x \\in {a,b}^* | \\text{ $x$ contains a substring of 3 consecutive $a$ s} }\n$$", 
            "title": "Example"
        }, 
        {
            "location": "/2-Finite-Automata/#closure", 
            "text": "definition : A set is  closed  under an operation if the result of the operation on an element of the set is also an element of the set.", 
            "title": "Closure"
        }, 
        {
            "location": "/2-Finite-Automata/#theorem", 
            "text": "If $L_1$ and $L_2$ are regular languages then so is $L_1 \\cup L_2$.", 
            "title": "Theorem"
        }, 
        {
            "location": "/3-Nondeterministic-Finite-Automata/", 
            "text": "Nondeterministic Finite Automata\n\n\nWe use \nnondeterministic finite automata (NFAs)\n to model systems with a variable number of states.", 
            "title": "Nondeterministic Finite Automata"
        }, 
        {
            "location": "/3-Nondeterministic-Finite-Automata/#nondeterministic-finite-automata", 
            "text": "We use  nondeterministic finite automata (NFAs)  to model systems with a variable number of states.", 
            "title": "Nondeterministic Finite Automata"
        }, 
        {
            "location": "/4-Regular-Expressions/", 
            "text": "Regular Expressions\n\n\nWe can use regular operations to build up \nregular expressions\n which describe languages.\n\n\nFor example,\n\n\n\n\n\n  (a \\cup b)a^*\n\n\n\n\n\nis an $a$ or a $b$ followed by zero or more $a$\ns.\n\n\nFormal Definition\n\n\nWe say $R$ is a \nregular expression\n if $R$ is\n\n\n\n\n$a$ for some $a$ in the alphabet $\\Sigma$,\n\n\n$\\varepsilon$,\n\n\n$\\varnothing$,\n\n\n$(R_1 \\cup R_2)$, where $R_1$ and $R_2$ are regular expressions,\n\n\n$(R_1 \\circ R_2)$, where $R_1$ and $R_2$ are regular expressions, or\n\n\n$(R)^*$, where $R$ is a regular expression.\n\n\n\n\nNote that $\\varepsilon$ is a language with only one string, the empty string ($\\epsilon$), and $\\varnothing$ is the language with no strings.\n\n\nRegular Expressions and Languages\n\n\nTheorem\n\n\nA language is regular if and only if some regular expression describes it.\n\n\nProof\n\n\nBase\n: \n\n\n\n\n\n\n\n\n$R$\n\n\n$L(R)$\n\n\n$M$\n1\n\n\n\n\n\n\n\n\n\n\n$\\varnothing$\n\n\n$\\varnothing$\n\n\n\n\n\n\n\n\n$\\varepsilon$\n\n\n${\\varepsilon}$\n\n\n\n\n\n\n\n\n$a$\n\n\n${a}$\n\n\n\n\n\n\n\n\n\n\nNondeterminate Finite Automata to Regular Expressions\n\n\nGiven any nondeterminate finite automata we can construct an eqivalent nondeterminate finite automata with\n\n\n\n\nexactly one accept state,\n\n\nno arrows to the start state,\n\n\nno arrows out of the accept state, and\n\n\nthe accept state is not the start state.\n\n\n\n\n\n\n\n\n\n\n\n\n$L(R) = L(M)$", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/4-Regular-Expressions/#regular-expressions", 
            "text": "We can use regular operations to build up  regular expressions  which describe languages.  For example,   \n  (a \\cup b)a^*   is an $a$ or a $b$ followed by zero or more $a$ s.", 
            "title": "Regular Expressions"
        }, 
        {
            "location": "/4-Regular-Expressions/#formal-definition", 
            "text": "We say $R$ is a  regular expression  if $R$ is   $a$ for some $a$ in the alphabet $\\Sigma$,  $\\varepsilon$,  $\\varnothing$,  $(R_1 \\cup R_2)$, where $R_1$ and $R_2$ are regular expressions,  $(R_1 \\circ R_2)$, where $R_1$ and $R_2$ are regular expressions, or  $(R)^*$, where $R$ is a regular expression.   Note that $\\varepsilon$ is a language with only one string, the empty string ($\\epsilon$), and $\\varnothing$ is the language with no strings.", 
            "title": "Formal Definition"
        }, 
        {
            "location": "/4-Regular-Expressions/#regular-expressions-and-languages", 
            "text": "", 
            "title": "Regular Expressions and Languages"
        }, 
        {
            "location": "/4-Regular-Expressions/#theorem", 
            "text": "A language is regular if and only if some regular expression describes it.", 
            "title": "Theorem"
        }, 
        {
            "location": "/4-Regular-Expressions/#proof", 
            "text": "Base :      $R$  $L(R)$  $M$ 1      $\\varnothing$  $\\varnothing$     $\\varepsilon$  ${\\varepsilon}$     $a$  ${a}$", 
            "title": "Proof"
        }, 
        {
            "location": "/4-Regular-Expressions/#nondeterminate-finite-automata-to-regular-expressions", 
            "text": "Given any nondeterminate finite automata we can construct an eqivalent nondeterminate finite automata with   exactly one accept state,  no arrows to the start state,  no arrows out of the accept state, and  the accept state is not the start state.       $L(R) = L(M)$", 
            "title": "Nondeterminate Finite Automata to Regular Expressions"
        }, 
        {
            "location": "/5-Minimizing/", 
            "text": "Minimizing Discreet Finite Automata\n\n\nGiven a discreet finite automaton, $M = (Q, \\Sigma, \\delta, q_0, F)$, for a language $L$, we canstruct a \nminimal\n discreet finite automaton with as few states as possible. This discreet finite automaton is isomorphically unique.\n\n\nProcess\n\n\nGiven $M = (Q, \\Sigma, \\delta, q_0, F)$, and $q \\in Q$, let $M_q$ be identical to $M$, but with state $q$ instead of $q_0$.\n\n\nThen $p$ and $q$ can be collapse if $L(M_p) = L(M_q)$.\n\n\nConsider $M$ with $p$ and $q$ collapsed to $pq$, let\ns call this $M^\\prime$.", 
            "title": "Minimization"
        }, 
        {
            "location": "/5-Minimizing/#minimizing-discreet-finite-automata", 
            "text": "Given a discreet finite automaton, $M = (Q, \\Sigma, \\delta, q_0, F)$, for a language $L$, we canstruct a  minimal  discreet finite automaton with as few states as possible. This discreet finite automaton is isomorphically unique.", 
            "title": "Minimizing Discreet Finite Automata"
        }, 
        {
            "location": "/5-Minimizing/#process", 
            "text": "Given $M = (Q, \\Sigma, \\delta, q_0, F)$, and $q \\in Q$, let $M_q$ be identical to $M$, but with state $q$ instead of $q_0$.  Then $p$ and $q$ can be collapse if $L(M_p) = L(M_q)$.  Consider $M$ with $p$ and $q$ collapsed to $pq$, let s call this $M^\\prime$.", 
            "title": "Process"
        }
    ]
}